# Официальные рекомендации
Основная информация о том, каких подходов следует придерживаться при написании когда непосредственно на C# приведена на **[MSDN](https://learn.microsoft.com/ru-ru/dotnet/csharp/fundamentals/coding-style/coding-conventions)**
Так же часть информации взята с соглашения **[RSDN](https://rsdn.org/article/mag/200401/codestyle.XML)**

### Уточнения, которые на MSDN не присутствуют

**Делегаты**: 
Пишем в следующем формате: 
```csharp
actionExapmle?.Invoke(args)
```

Причина в том, что здесь лаконично встроена проверка на null, которая будет необходима почти всегда воизбежание неожиданностей. 

**Оператор `new`** - везде где можно используем запись вида `new ()`. А значит в объявлениях локальных функциях заменяем `var` на создаваемый тип. 
Пример:
```csharp
// Before
var exapmleClass = new ExapmleClass();

// After
ExapmleClass exapmleClass = new ();
```

**Обработка событий** - лямбда-выражения используются только для коротких обработчиков не содержащих вычисления. Во всех остальных случаях *обработчики* выносятся в отдельный метод.

> [!warning]
> Не стоит забывать и отписываться от ивентов когда это возможно.
> В случае использования обычного метода, все просто. А вот отписать анонимную функцию не получится если заранее её где-то не закэшировать. 
> Поэтому следует послушать совет Microsoft и в случае, *когда вам нужно отписываться от события* использовать полноценный метод.

Так же часто при использовании иветов забывается такая особенность языка, как *"замыкания"*. 

Чего-то особо страшного из-за них, как правило, не происходит. 
Но часто возникает ситуация с циклом for, в котором регистрируется анонимное событие захватывающее переменную i, которую часто используют как стандартную для обозначения номера итерации.

Вот так выглядит код с замыканием, который иногда вызывает непонимание у тех, кто с ними встретился впервые. 
```csharp
Action someAction;

for(var i = 0; i < 10; i++)
{
	someAction = () => Console.Write(i);
}

someAction?.Invoke(); // 10

// Понять почему так происходит будет сильно проще, если посмотреть как это выглядит внутри. 

class DisplayClass
{
	internal int i;

	internal void AnonymousMethod001()
	{
		Console.Write(i + " ");
	}
}

Action someAction;

AnonymousClass c = new AnonymousClass001();
for(c.i = 0; c.i < 10; c.i++)
{
	someAction = c.AnonymousMethod001;
}

```

Решение конретно описанной выше проблемы выглядит очень просто:
```csharp
Action someAction;

for(var i = 0; i < 10; i++)
{
	var j = i;
	someAction = () => Console.Write(j);
}

someAction?.Invoke(); // 10

// Понять почему так происходит будет сильно проще, если посмотреть как это выглядит внутри. 

class DisplayClass
{
	internal int j;

	internal void AnonymousMethod001()
	{
		Console.Write(j + " ");
	}
}

Action someAction;

for(var i = 0; i < 10; i++)
{
	AnonymousClass c = new AnonymousClass001();
	c.j = i;
	someAction = c.AnonymousMethod001;
}

```

> [!note]
> Код в разделе с замыканием является обобщенным представлением того, что собирается из вашего кода в Low-Level C#

> [!note]
> Не могу сказать, что когда-то встречал острую необходимость знать что такое замыкания, но на всякий случай вот где можно узнать о них по больше:
>
> [C# и .NET | Замыкания (metanit.com)](https://metanit.com/sharp/tutorial/3.54.php)
> [Магия замыканий C#. Краткий обзор работы замыканий в C# | Илиас Шейх | Стартап | Терпимая (medium.com)](https://medium.com/swlh/the-magic-of-c-closures-9c6e3fff6ff9) - самое подробное объяснение

**Запросы LINQ** - если код выполняется часто то желательно отказаться от использования LINQ в пользу более оптимизированных методов(как пример, использование Array.Sort, для сортировки, вместо OrderBy). 
Хорошей практикой использовать LINQ-запросы на инициализации типа за время до начала геймплея, особенно, если коллеции к которым приеняются запросы вы не можете однозначно назвать "маленькими".

> [!note]
> Причина такого правила проста. Вызов каждого метода-расширения LINQ создает дополнительный класс, вызывая тем самым аллокации. А конструкции `.ToList \ .ToDictionary` сами по себе говорят о выделении дополнительной памяти.
> 
> И необходимо этого избегать во всех местах, что могут стать "узким горлышком" всего проекта.

**Комментарии** - очень желательно избегать их существования в принципе.

> [!note]
> Тем не менее исключения есть. 
> 
> Комментарии к методам \ классам со сложной логикой описать которую можно только прикрепив ссылку на документацию или кратким но внятным изложением происходящего. 
> 
> А так же **`summary`** для генерации документации или в ситуациях, когда вы пишете библиотечный код, который необходимо впоследствии сделать доступным, во всех смыслах, для сторонних разработчиков.


**TODO** - не используются. Альтернативой служит вынесение на обсуждение и последующее создание задачи или отказ от действий. 

**XML-комментарии** - не используются, если только вы не пишете публичный API. 

> [!note]
> К примеру, когда вы пишете класс в C# своего внутреннего проекта, то писать там XML-комментарии будет скорее моветоном и показателем не достаточно хорошо прописанного класса. 
> 
> В то же время если пишется EditorScript или вспомогательный метод с "особым" поведением. То к такому коду XML-комментарии могут быть написаны но лишь в случае острой в них необходимости. 
> 
> Ну и ситуацией, когда XML-комментарии скорее необходимы, это когда вы пишете публичный API с которым будут работать только на вызов люди, которым не нужно лезть в детали реализации что бы понять, что произойдет. 

# Последовательность членов типа
Для большего удобства при "чтении" кода, необходимо всем придерживаться определенных правил не только в нейминге, но и в расположении членов типа.

Предпочтение отдается выделению взаимосвязынных членов в одну группу с учетом приведенных ниже правил, но уже относительно группы. 
Тем не менее **все поля располагаются в начале типа и никогда не располагаются между методами.**
 
 ```csharp
[Header("View data")]
[SerializeField] private Image icon;
private Sprite _currentIcon;
public string CurrentIconName => currentIcon.name;

[Header("Timer data")]
[SerializeField] private int timerLenghtAtSeconds;
private Task _currentTimer;
private CancellationTokenSource _currentTimerToken_;
```

Так же внутри взаимосвязной группы желательно рядом друг с другом держать члены одного типа(List под List \ int под int и т.д). 

```csharp
private int _firstValue;
private int _secondValue;
private string _firstName;
private string _secondName;
private int[] _integers_;
private string[] _strings;
```

Глобально последовательность сортировки членов класса по подификаторам должна выглядеть так:
- `public -> [SerializeField] private -> protected -> internal -> private -> new -> abstract -> virtual -> override -> sealed -> static -> readonly -> extern -> unsafe -> volatile -> async`.
Члены класса располагаются в следующем порядке:
- Внутренние классы, структуры, перечисления. 
- Поля, свойства.
- Статические поля, константы и readonly-поля \ свойства.
- Конструкторы и финализаторы. 
- Методы.
Внутри каждой группы элементы должны располагаться в следующем порядке:
- `public -> internal -> protected internal -> protected -> private`

С методами есть одна особенность. Располагать их нужно в предполагаемом порядке вызова. Но сохраняя при этом правило *работы с публичными и приватными методами*.

```csharp
 public sealed class exampleClass
 {
 	public void ShowExample() {}
 	public void HideExapmle() {}
 	private void StartExapmleWork() {}
 	private void OnUpdateExapmleView() {}
 	private void OnExapmleCompleteWork() {}
 	private void AutoHideExapmle(){}
 }
```

Здесь логика последовательна, но при этом сохраняются и *private \ public* правила. 

# Именование идентификаторов
Здесь я за основу беру правила *именования идентификаторов* от **[RSDN](https://rsdn.org/article/mag/200401/codestyle.XML)**. При этом есть лишь одно замечание.

- Именование *`[SerializeField] private protected internal`* - полей пишется **без** нижнего подчеркивания. Иначе говоря, идентично *`public`* полям.

>[!note]
>Поскольку и *`public`* и *`[SerializeField] private protected internal`* поля могут быть модифицированы в инспекторе, куда целесообразнее видеть их одинаковыми, что бы сразу понимать ситуацию.

# Константы
- Если нужно неизменяемое поле с уже известным значением, используем модификатор `const`.
- Если нужно неизменяемое поле значение которого вычисляется в пределах конструктора, используем `readonly`.
- Все "магические числа" необходимо заменять на const.

> [!note]
> После компиляции поля помеченные как `const` перестают существовать, а в местах обращений к ним просто подставляется их значение. 
> 
> Отсюда исходит и особенность, при работе с одной константой в нескольких сборках. 
> Т.к при изменении константы, нужно перестраивать обе сборки, иначе значения будут отличаться. 

# Конкретнее о методах

- Использование **[expression bodies](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members)** там где это возможно. 
> [!note]
> Считаю целесообразным использование *expression bodies* в ситуациях, когда тело метода можно представить исключительно возвращаемым значением.

- Использование модификатора **`in`** когда в метод передается `class` состояние которых должно оставаться неизменным. При передаче `struct` стоит задуматься на сколько необходимо и допустимо использование данного модификатора для производительности. 
>[!warning]
> Не правильное использование *`in`* с типом `struct` может привести к проблемам с производительностью!

> [!note]
> Как правило использовать *`in`* имеет смысл в ситуациях с "большими" структурами что бы не создавать лишнюю копию в процессе передачи и в процессе работы со структурой в методе.

- По возможности ограничить методы размером до 50-70  строк. 
- Количество аргументов метода не должно превышать 10.

> [!tip]
> В случае неуверенности в понимании того, что такое *`in`* и как оно работает можно почитать немного информации по ссылкам ниже.
>
>[c# 7.2 - Why would one ever use the "in" parameter modifier in C#? - Stack Overflow](https://stackoverflow.com/questions/52820372/why-would-one-ever-use-the-in-parameter-modifier-in-c)
>[The ‘in’-modifier and the readonly structs in C# - Developer Support (microsoft.com)](https://devblogs.microsoft.com/premier-developer/the-in-modifier-and-the-readonly-structs-in-c/)

- Использовать `IReadOnlyList / IReadOnlyDictionary / IReadOnlyCollection / IEnumerable` в качестве входных данных для обеспечения неизменяемости коллекций.  ^72c779

# Конкретнее о классах

- Для всех классов, от которых не подразумевается возможность наследования используем модификатор *`sealed`*.
- Количество аргументов конструктора недолжно превышать 10.
- Классы, которым нужно обеспечить неизменяемость, а так же используемые для сравнения в качестве ключа(или чего-то в этом роде), заменяются на *[`record`](https://habr.com/ru/amp/publications/675560/)*.
- Обобщенные классы, по возможности, должны иметь модификатор *`where`* с указанием родительских типов.

```csharp
public class AGenericClass<Т> where T : IComparable<Т> { }; 
```

# Nullable типы

- Если тип по какой-то причине может быть `null`, не зависимо от того ссылочный он или значимый, он должен быть `Nullable`, но использовать конструкцию `Nullable<T>` явно смысла нет, достаточно использовать `?`

>[!tip]
> https://habr.com/ru/articles/786082/?utm_campaign=786082&utm_source=habrahabr&utm_medium=rss

# List vs Array

- Используйте `List<>` если размер коллекции может изменяться.
- В качестве публичной или возвращаемой коллекции имеет смысл использовать `List<>` учитывая информацию про `IReadOnlyList / IEnumerable` расположенную выше.
- Используйте массивы, для многомерных коллекций.
- Используйте массивы, если длина коллекции неизменяема и заранее известна.

# Throw Exception

- Генерировать исключение имеет смысл только в тех случаях, когда от результата работы метода зависит дальнейшая стабильность приложения. Во всех остальных случаях имеет смысл использовать иные способы регистрации проблем, которые не портят пользовательский опыт.
> [!note]
> Здесь все зависит от используемых у вас инструментов. Можете просто писать Debug.Log и записывать все это в файл(плохой совет), можете использовать аналитические сервисы, такие как Sentry / Crashlytics. Можете так же попробовать и иные способы логирования, подходящих под ваши потребности.

# Рекомендации

### IsNullOrEmpty vs IsNullOrWhiteSpace
- Если пробел в качестве единственного символа это все равно ошибка, используйте `IsNullOrWhiteSpace`.
- Если пробел в качестве единственного символа это валидное значение, используйте `IsNullOrEmpty`.
- [Сами Microsoft заявляют, что IsNullOrWhiteSpace быстрее](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.isnullorwhitespace?view=net-8.0) но если посмотреть исходный код, то тело этого метода более громоздкое в плане инструкций, что заставляет сомневаться  в словах MSDN.

[Source code:](https://referencesource.microsoft.com/mscorlib/R/55e241b6143365ef.html)
```csharp
[Pure]
public static bool IsNullOrEmpty(String value) {
	return (value == null || value.Length == 0);
}

[Pure]
public static bool IsNullOrWhiteSpace(String value) {
	if (value == null) return true;

	for(int i = 0; i < value.Length; i++) {
		if(!Char.IsWhiteSpace(value[i])) return false;
	}

	return true;
}
```

- Если нужно присвоить значение какой-то переменной лишь в случае, когда она равна `null` то можно обойтись без конструкции `if` обойдясь следующей записью:
```csharp
SomeClass someVar;

someVar ??= new SomeClass(); 
```
Здесь весь "`if`" спрятан в операторе `??`.

- По возможности не стоит опускать **Pattern Matching**.

> [!tip]
> Почитать о нем можно по ссылкам ниже:
> 
> [Patterns - Pattern matching using the is and switch expressions. - C# | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#constant-pattern)
> [C# и .NET | Pattern matching (metanit.com)](https://metanit.com/sharp/tutorial/3.34.php)
